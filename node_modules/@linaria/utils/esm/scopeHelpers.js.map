{"version":3,"file":"scopeHelpers.js","names":["NODE_FIELDS","findIdentifiers","nonType","getScope","isNotNull","isRemoved","validateField","node","key","val","field","validate","optional","getBinding","path","binding","name","undefined","reference","referencePath","force","isReferencedIdentifier","referencePaths","includes","referenced","references","push","isReferenced","kind","some","i","find","ancestor","isTSType","isFlowType","dereference","filter","length","dereferenceAll","map","identifierPath","referenceAll","forEach","deletingNodes","WeakSet","isEmptyList","list","every","has","getPathFromAction","action","Array","isArray","Error","findActionForNode","add","parent","parentPath","isProgram","isFunction","listKey","isLogicalExpression","operator","type","value","isObjectProperty","get","isIdentifier","maybeDefineProperty","isCallExpression","matchesPattern","isTemplateLiteral","isAssignmentExpression","isForInStatement","left","isFunctionExpression","body","isFunctionDeclaration","isObjectMethod","isClassMethod","isBlockStatement","prevStatement","isIfStatement","isReturnStatement","slice","statement","isVariableDeclarator","isExportNamedDeclaration","declaration","isTryStatement","referenceEnums","program","traverse","ExpressionStatement","expressionStatement","expression","callee","args","arg","fixed","removeUnreferenced","items","Set","item","hasReferences","forDeleting","constantViolations","identifier","removeWithRelated","result","sort","a","b","localeCompare","paths","rootPath","getProgramParent","actions","affectedPaths","referencedIdentifiers","referencesOfBinding","reduce","acc","mutate","p","remove","replaceWith","clean","join","fn","dereferenced","mutated","dead","assignments","assignment","scope","declared","Object","values","getOuterBindingIdentifiers","Identifier","isArrayPattern","elements"],"sources":["../src/scopeHelpers.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n\nimport type { Binding, NodePath } from '@babel/traverse';\nimport type {\n  Node,\n  Identifier,\n  JSXIdentifier,\n  Program,\n  FieldOptions,\n} from '@babel/types';\nimport { NODE_FIELDS } from '@babel/types';\n\nimport findIdentifiers, { nonType } from './findIdentifiers';\nimport { getScope } from './getScope';\nimport isNotNull from './isNotNull';\nimport isRemoved from './isRemoved';\n\nfunction validateField(\n  node: Node,\n  key: string,\n  val: unknown,\n  field: FieldOptions\n) {\n  if (!(field != null && field.validate)) return true;\n  if (field.optional && val == null) return true;\n  try {\n    field.validate(node, key, val);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction getBinding(path: NodePath<Identifier | JSXIdentifier>) {\n  const binding = getScope(path).getBinding(path.node.name);\n  if (!binding) {\n    return undefined;\n  }\n\n  return binding;\n}\n\nexport function reference(\n  path: NodePath<Identifier | JSXIdentifier>,\n  referencePath: NodePath = path,\n  force = false\n): void {\n  if (!force && !path.isReferencedIdentifier()) return;\n\n  const binding = getBinding(path);\n  if (!binding) return;\n\n  if (binding.referencePaths.includes(referencePath)) {\n    return;\n  }\n\n  binding.referenced = true;\n  binding.references += 1;\n  binding.referencePaths.push(referencePath ?? path);\n}\n\nfunction isReferenced(binding: Binding) {\n  if (!binding.referenced) {\n    return false;\n  }\n\n  // If it's a param binding, we can't just remove it\n  // because it brakes the function signature. Keep it alive for now.\n  if ((binding.kind as string) === 'param') {\n    return true;\n  }\n\n  // If all remaining references are in TS/Flow types, binding is unreferenced\n  return binding.referencePaths.some(\n    (i) => !i.find((ancestor) => ancestor.isTSType() || ancestor.isFlowType())\n  );\n}\n\nexport function dereference(\n  path: NodePath<Identifier | JSXIdentifier>\n): Binding | null {\n  const binding = getBinding(path);\n  if (!binding) return null;\n\n  if (!binding.referencePaths.includes(path)) {\n    return null;\n  }\n\n  binding.references -= 1;\n  binding.referencePaths = binding.referencePaths.filter((i) => i !== path);\n  binding.referenced = binding.referencePaths.length > 0;\n\n  return binding;\n}\n\nfunction dereferenceAll(path: NodePath): Binding[] {\n  return findIdentifiers([path])\n    .map((identifierPath) => dereference(identifierPath))\n    .filter(isNotNull);\n}\n\nexport function referenceAll(path: NodePath): void {\n  findIdentifiers([path]).forEach((identifierPath) =>\n    reference(identifierPath)\n  );\n}\n\nconst deletingNodes = new WeakSet<NodePath>();\n\nconst isEmptyList = (list: NodePath[]) =>\n  list.length === 0 || list.every((i) => deletingNodes.has(i));\n\ntype ReplaceAction = [action: 'replace', what: NodePath, by: Node];\ntype RemoveAction = [action: 'remove', what: NodePath];\n\nconst getPathFromAction = (action: RemoveAction | ReplaceAction) => {\n  if (!Array.isArray(action)) {\n    return action;\n  }\n\n  if (action[0] === 'replace' || action[0] === 'remove') {\n    return action[1];\n  }\n\n  throw new Error(`Unknown action type: ${action[0]}`);\n};\n\nexport function findActionForNode(\n  path: NodePath\n): RemoveAction | ReplaceAction | null {\n  if (isRemoved(path)) return null;\n\n  deletingNodes.add(path);\n\n  const parent = path.parentPath;\n\n  if (!parent) return ['remove', path];\n\n  if (parent.isProgram()) {\n    // Do not delete Program node\n    return ['remove', path];\n  }\n\n  if (parent.isFunction() && path.listKey === 'params') {\n    // Do not remove params of functions\n    return null;\n  }\n\n  if (parent.isLogicalExpression({ operator: '&&' })) {\n    return [\n      'replace',\n      parent,\n      {\n        type: 'BooleanLiteral',\n        value: false,\n      },\n    ];\n  }\n\n  if (parent.isObjectProperty()) {\n    // let's check if it is a special case with Object.defineProperty\n    const key = parent.get('key');\n    if (key.isIdentifier({ name: 'get' })) {\n      const maybeDefineProperty = parent.parentPath.parentPath;\n      if (\n        maybeDefineProperty?.isCallExpression() &&\n        maybeDefineProperty\n          .get('callee')\n          .matchesPattern('Object.defineProperty')\n      ) {\n        return findActionForNode(maybeDefineProperty);\n      }\n    }\n\n    return findActionForNode(parent);\n  }\n\n  if (parent.isTemplateLiteral()) {\n    return [\n      'replace',\n      path,\n      {\n        type: 'StringLiteral',\n        value: '',\n      },\n    ];\n  }\n\n  if (parent.isAssignmentExpression()) {\n    return findActionForNode(parent);\n  }\n\n  if (parent.isCallExpression()) {\n    return findActionForNode(parent);\n  }\n\n  if (parent.isForInStatement({ left: path.node })) {\n    return findActionForNode(parent);\n  }\n\n  if (\n    parent.isFunctionExpression({ body: path.node }) ||\n    parent.isFunctionDeclaration() ||\n    parent.isObjectMethod() ||\n    parent.isClassMethod()\n  ) {\n    return findActionForNode(parent);\n  }\n\n  if (parent.isBlockStatement()) {\n    const body = parent.get('body');\n    if (isEmptyList(body)) {\n      return findActionForNode(parent);\n    }\n\n    if (path.listKey === 'body' && typeof path.key === 'number') {\n      if (path.key > 0) {\n        // We can check whether the previous one can be removed\n        const prevStatement = body[path.key - 1];\n        if (\n          prevStatement.isIfStatement() &&\n          prevStatement.get('consequent').isReturnStatement()\n        ) {\n          // It's `if (…) return …`, we can remove it.\n          return findActionForNode(prevStatement);\n        }\n      } else if (\n        body.slice(1).every((statement) => deletingNodes.has(statement))\n      ) {\n        // If it is the first statement and all other statements\n        // are marked for deletion, we can remove the whole block.\n        return findActionForNode(parent);\n      }\n    }\n  }\n\n  if (parent.isVariableDeclarator()) {\n    return findActionForNode(parent);\n  }\n\n  if (\n    parent.isExportNamedDeclaration() &&\n    ((path.key === 'specifiers' && isEmptyList(parent.get('specifiers'))) ||\n      (path.key === 'declaration' && parent.node.declaration === path.node))\n  ) {\n    return findActionForNode(parent);\n  }\n\n  for (const key of ['body', 'declarations', 'specifiers']) {\n    if (path.listKey === key && typeof path.key === 'number') {\n      const list = parent.get(key) as NodePath[];\n      if (isEmptyList(list)) {\n        return findActionForNode(parent);\n      }\n    }\n  }\n\n  if (parent.isTryStatement()) {\n    return findActionForNode(parent);\n  }\n\n  if (!path.listKey) {\n    const field = NODE_FIELDS[parent.type][path.key];\n    if (!validateField(parent.node, path.key as string, null, field)) {\n      // The parent node isn't valid without this field, so we should remove it also.\n      return findActionForNode(parent);\n    }\n  }\n\n  for (const key of [\n    'argument',\n    'block',\n    'body',\n    'callee',\n    'discriminant',\n    'expression',\n    'id',\n    'left',\n    'object',\n    'property',\n    'right',\n    'test',\n  ]) {\n    if (path.key === key && parent.get(key) === path) {\n      return findActionForNode(parent);\n    }\n  }\n\n  return ['remove', path];\n}\n\n// @babel/preset-typescript transpiles enums, but doesn't reference used identifiers.\nfunction referenceEnums(program: NodePath<Program>) {\n  /*\n   * We are looking for transpiled enums.\n   *   (function (Colors) {\n   *     Colors[\"BLUE\"] = \"#27509A\";\n   *   })(Colors || (Colors = {}));\n   */\n  program.traverse({\n    ExpressionStatement(expressionStatement) {\n      const expression = expressionStatement.get('expression');\n      if (!expression.isCallExpression()) return;\n\n      const callee = expression.get('callee');\n      const args = expression.get('arguments');\n      if (!callee.isFunctionExpression() || args.length !== 1) return;\n      const [arg] = args;\n      if (arg.isLogicalExpression({ operator: '||' })) {\n        referenceAll(arg);\n      }\n    },\n  });\n}\n\nconst fixed = new WeakSet<NodePath<Program>>();\n\nfunction removeUnreferenced(items: NodePath<Identifier | JSXIdentifier>[]) {\n  const referenced = new Set<NodePath<Identifier | JSXIdentifier>>();\n  items.forEach((item) => {\n    if (!item.node || isRemoved(item)) return;\n    const binding = getScope(item).getBinding(item.node.name);\n    if (!binding) return;\n    const hasReferences =\n      binding.referencePaths.filter((i) => !isRemoved(i)).length > 0;\n    if (hasReferences) {\n      referenced.add(item);\n      return;\n    }\n\n    const forDeleting = [binding.path, ...binding.constantViolations]\n      .map(findActionForNode)\n      .filter(isNotNull)\n      .map(getPathFromAction);\n\n    if (forDeleting.length === 0) return;\n\n    findIdentifiers(forDeleting).forEach((identifier) => {\n      referenced.add(identifier);\n    });\n\n    removeWithRelated(forDeleting);\n  });\n\n  const result = [...referenced];\n  result.sort((a, b) => a.node?.name.localeCompare(b.node?.name));\n\n  return result;\n}\n\nfunction removeWithRelated(paths: NodePath[]) {\n  if (paths.length === 0) return;\n\n  const rootPath = getScope(paths[0]).getProgramParent()\n    .path as NodePath<Program>;\n\n  if (!fixed.has(rootPath)) {\n    // Some libraries don't care about bindings, references, and other staff\n    // So we have to fix the scope before we can detect unused code\n    referenceEnums(rootPath);\n    fixed.add(rootPath);\n  }\n\n  const actions: (ReplaceAction | RemoveAction)[] = paths\n    .map(findActionForNode)\n    .filter(isNotNull);\n\n  const affectedPaths = actions.map(getPathFromAction);\n\n  let referencedIdentifiers = findIdentifiers(affectedPaths, 'referenced');\n  referencedIdentifiers.sort((a, b) =>\n    a.node?.name.localeCompare(b.node?.name)\n  );\n\n  const referencesOfBinding = findIdentifiers(affectedPaths, 'binding')\n    .map((i) => (i.node && getScope(i).getBinding(i.node.name)) ?? null)\n    .filter(isNotNull)\n    .reduce(\n      (acc, i) => [...acc, ...i.referencePaths.filter(nonType)],\n      [] as NodePath[]\n    );\n\n  actions.forEach((action) => {\n    mutate(action[1], (p) => {\n      if (isRemoved(p)) return;\n\n      if (action[0] === 'remove') {\n        p.remove();\n      } else if (action[0] === 'replace') {\n        p.replaceWith(action[2]);\n      }\n    });\n  });\n\n  removeWithRelated(referencesOfBinding);\n\n  let clean = false;\n  while (!clean && referencedIdentifiers.length > 0) {\n    const referenced = removeUnreferenced(referencedIdentifiers);\n    clean =\n      referenced.map((i) => i.node?.name).join('|') ===\n      referencedIdentifiers.map((i) => i.node?.name).join('|');\n    referencedIdentifiers = referenced;\n  }\n}\n\nfunction mutate<T extends NodePath>(path: T, fn: (p: T) => NodePath[] | void) {\n  const dereferenced = dereferenceAll(path);\n\n  const mutated = fn(path);\n\n  referenceAll(path);\n  mutated?.forEach((p) => referenceAll(p));\n\n  const dead = dereferenced.filter((p) => !isReferenced(p));\n\n  const forDeleting: NodePath[] = [];\n  dead.forEach((binding) => {\n    const assignments = [binding.path, ...binding.constantViolations];\n    assignments.forEach((assignment) => {\n      const { scope } = assignment;\n      const declared = Object.values(\n        assignment.getOuterBindingIdentifiers(false)\n      );\n      if (\n        declared.length === 1 &&\n        'name' in declared[0] &&\n        declared[0].name === binding.identifier.name\n      ) {\n        // Only one identifier is declared, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      if (\n        declared.every(\n          (identifier) =>\n            identifier.type === 'Identifier' &&\n            !scope.getBinding(identifier.name)?.referenced\n        )\n      ) {\n        // No other identifier is referenced, so we can remove the whole declaration\n        forDeleting.push(assignment);\n        return;\n      }\n\n      // We can't remove the binding, but we can remove the part of it\n      assignment.traverse({\n        Identifier(identifier) {\n          if (identifier.node.name === binding.identifier.name) {\n            const parent = identifier.parentPath;\n            if (\n              parent.isArrayPattern() &&\n              identifier.listKey === 'elements' &&\n              typeof identifier.key === 'number'\n            ) {\n              parent.node.elements[identifier.key] = null;\n            } else if (parent.isObjectProperty()) {\n              forDeleting.push(parent);\n            }\n          }\n        },\n      });\n    });\n  });\n\n  removeWithRelated(forDeleting);\n}\n\nexport { mutate, removeWithRelated };\n"],"mappings":"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"}